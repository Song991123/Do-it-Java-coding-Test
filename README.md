## Do it! 알고리즘 자바편 학습 기록

## 📅 6월 9일 회고
- 시간복잡도 이론 정리
- 디버깅 실습
- GitHub 저장소 초기화

## 📅 6월 10일 회고

### ✅ 1. 학습한 개념 요약
- 배열과 리스트의 차이
  - 배열: 고정 크기, 접근 빠름, 삽입/삭제 어려움
  - 리스트: 동적 크기, 삽입/삭제 쉬움, 접근 느림
- Java에서 배열과 ArrayList 사용법 복습

### 🔍 2. 문제 풀이
- [백준 11720번 - 숫자의 합](https://www.acmicpc.net/problem/11720)
- [백준 1546번 - 평균 구하기](https://www.acmicpc.net/problem/1546)

---

## 📅 6월 11일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 구간 합 알고리즘
- 합 배열 `S`를 만들어 누적합을 저장한 후,  
  원하는 구간의 합은 `S[j] - S[i-1]`으로 계산
- 시간복잡도를 `O(1)`로 줄이기 위해 사전 계산 방식 사용
- `S.length = A.length + 1`인 이유:  
  인덱스 `0`부터 시작해 `S[0] = 0`을 두고 `S[1] = A[0]`부터 누적해나가기 위함

#### 📌 투 포인터 알고리즘
- 두 개의 인덱스를 앞뒤로 움직이며 구간 조건을 만족하는지 탐색
- 주로 **정렬된 배열**, **부분 합**, **쌍 찾기** 등에 사용
- 시간복잡도를 `O(N)` 수준으로 줄이는 데 유리

### 🔍 2. 문제 풀이
- [백준 11659번 - 구간 합 구하기 1](https://www.acmicpc.net/problem/11659)
- [백준 2018번 - 연속된 자연수의 합 구하기](https://www.acmicpc.net/problem/2018)

---

## 📅 6월 12일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 슬라이딩 윈도우 알고리즘
- 고정된 범위의 창(window)을 좌→우로 이동하며 조건을 검사
- 이전 상태를 활용해 연산량을 줄이므로 `O(N)` 시간복잡도 가능

#### 📌 투 포인터 알고리즘 복습
- 정렬된 배열에서 쌍, 구간합 등을 빠르게 찾기 위해 사용하는 방법
- 주로 `i`, `j` 두 개의 인덱스를 활용
- 정렬이 안 되어 있다면 `O(nlogn)`가 가능한 상황인지 확인 후, 선 정렬 후 사용

### 🔍 2. 문제 풀이
- [백준 1940번 - 주몽의 명령](https://www.acmicpc.net/problem/1940)
- [백준 12891번 - DNA 비밀번호](https://www.acmicpc.net/problem/12891)

---

## 📅 6월 13일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 스택 (Stack)
- LIFO (Last In First Out) 구조
- `push()` → 데이터 삽입, `pop()` → 데이터 제거
- 괄호 검사, 수식 계산, DFS 등에서 자주 활용

#### 📌 큐 (Queue)
- FIFO (First In First Out) 구조
- `add()` → 삽입, `poll()` → 제거
- BFS, 순차적 처리 로직에서 활용
- `Queue`는 인터페이스이므로 `new Queue()`는 불가 → `LinkedList`로 구현

#### 📌 우선순위 큐 (PriorityQueue)
- 내부적으로 힙(Heap) 구조 사용
- 기본 정렬 기준은 최소 힙 (값이 작을수록 우선)
- 커스텀 정렬 시 `Comparator`를 사용하여 기준 변경

### 🔍 2. 문제 풀이

- [백준 1874번 - 스택 수열](https://www.acmicpc.net/problem/1874)
- [백준 2164번 - 카드2](https://www.acmicpc.net/problem/2164)
- [백준 11286번 - 절댓값 힙](https://www.acmicpc.net/problem/11286)

---

## 📅 6월 16일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 버블 정렬 (Bubble Sort)
- 인접한 두 데이터를 비교하여 큰 값을 뒤로 보내는 방식.
- 한 번의 반복문마다 가장 큰 값이 맨 뒤로 "거품처럼" 이동.
- 구현이 간단하지만, 성능은 좋지 않음.

#### 📌 선택 정렬 (Selection Sort)
- 현재 위치에 들어갈 값을 선택해서 자리를 바꾸는 방식.
- 전체 데이터에서 가장 작은(또는 큰) 값을 골라 교환.
- 불필요한 교환이 적으나, 비교 횟수는 많음.

#### 📌 삽입 정렬 (Insertion Sort)
- 이미 정렬된 부분에 새 데이터를 삽입하는 방식.
- 현재 값을 왼쪽으로 비교해가며 적절한 위치에 삽입.
- 최선의 경우(거의 정렬된 경우)에는 O(n)의 시간복잡도를 가지나, 일반적으로는 O(n²).

### 🔍 2. 문제 풀이

- [백준 2750번 - 수 정렬하기 1 (버블 정렬)](https://www.acmicpc.net/problem/2750)
- [백준 1427번 - 자릿수 내림차순 정렬 (선택 정렬)](https://www.acmicpc.net/problem/1427)

### 🧠 3. 시간복잡도 및 특성 비교

| 정렬 방식 | 최악 시간복잡도 | 특징 |
|-----------|----------------|------|
| 버블 정렬 | O(n²)         | 가장 단순, 자주 소개되는 방식 |
| 선택 정렬 | O(n²)         | 비교는 많지만 교환이 적음 |
| 삽입 정렬 | O(n²)         | 정렬된 상태에 가까울수록 효율적 (최선 O(n)) |

---

## 📅 6월 17일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 퀵 정렬 (Quick Sort)
- 피봇을 기준으로 좌우로 분할하며 정렬
- 왼쪽 포인터는 피봇보다 큰 값에서 멈추고, 오른쪽 포인터는 피봇보다 작은 값에서 멈추며 교환
- 이후 두 포인터가 만나면 피봇과 위치를 바꿔 정렬 범위 분할
- **평균 시간복잡도:** `O(n log n)`  
- **최악 시간복잡도:** `O(n^2)` (편향된 분할 시)

#### 📌 병합 정렬 (Merge Sort)
- 데이터를 재귀적으로 반으로 나누고 정렬된 상태로 병합
- 분할 후 병합하면서 정렬되도록 만듦
- **시간복잡도:** `O(n log n)`  
- **안정 정렬이며, 안정성이 필요할 때 유용**

#### 📌 기수 정렬 (Radix Sort)
- 자릿수별로 정렬하며 전체 데이터를 정렬
- 큐 10개(0~9)를 사용하여 일의 자리부터 차례로 정렬
- 정렬 기준은 가장 작은 자리수부터
- **시간복잡도:** `O(k * n)` (k: 자릿수, n: 데이터 개수)

---

## 📅 6월 19일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 DFS (깊이 우선 탐색)
- **방식:** 한 방향으로 계속 깊게 탐색하다가 더 이상 못 가면 되돌아오는 방식 (재귀 or 스택).
- **활용:** 그래프 탐색, 연결 요소 탐색 등.
- **특징:** 백트래킹 구조, 방문 체크 필수.

#### 📌 BFS (너비 우선 탐색)
- **방식:** 현재 노드 기준으로 인접한 노드를 먼저 방문하며 탐색하는 방식 (큐 사용).
- **활용:** 최단 경로 탐색 문제에서 효과적.
- **특징:** 레벨 탐색, 거리 누적 기록.

### 🔍 2. 문제 풀이

- [백준 11724번 - 연결 요소의 개수](https://www.acmicpc.net/problem/11724)
- [백준 2178번 - 미로 탐색](https://www.acmicpc.net/problem/2178)

---

## 📅 6월 20일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 이진 탐색 (Binary Search)
- 정렬된 배열에서 특정 값을 빠르게 찾는 알고리즘
- 탐색 구간을 절반씩 줄여가며 대상 값을 찾는다.
- 중앙값(mid)을 기준으로, 탐색 값이 더 작으면 왼쪽(high = mid - 1),더 크면 오른쪽(low = mid + 1) 구간으로 이동

### 🔍 2. 문제 풀이

- [백준 1920번 - 원하는 정수 찾기](https://www.acmicpc.net/problem/1920)

---

## 📅 6월 23일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 누적합 배열 초기화

```D[i][j] = D[i-1][j] + D[i][j-1] - D[i-1][j-1] + A[i][j];```

- 위/좌측에서 누적된 합을 가져오고, 두 번 중복된 좌상단을 빼준 뒤 현재 값을 더함.
- 포인트 : - D[i-1][j-1]은 중복 영역 제거를 위한 필수 처리.

#### 📌 구간합 구하기

```result = D[x2][y2] - D[x1-1][y2] - D[x2][y1-1] + D[x1-1][y1-1];```

-  D[x1-1][y1-1]은 중복된 제거 영역 보완

### 🔍 2. 문제 풀이

- [백준 11660 - 구간 합 구하기 2](https://www.acmicpc.net/problem/11660)

---

## 📅 6월 24일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 나머지 합 (누적합 + 나머지 조합)

- 누적합 배열 `S`를 만들고, 각 `S[i] % M`을 계산
- 나머지가 같은 두 구간의 차이는 `M`의 배수이므로 정답 후보가 됨
- 나머지 값이 0인 경우는 그 자체로 나누어 떨어지므로 따로 처리
- 나머지 값이 같은 것들끼리는 `조합 nC2`를 통해 정답 개수 계산

### 🔍 2. 문제 풀이

- [백준 10986 - 나머지 합](https://www.acmicpc.net/problem/110986)

---
