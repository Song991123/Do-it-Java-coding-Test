## Do it! 알고리즘 자바편 학습 기록

## 📅 6월 9일 회고
- 시간복잡도 이론 정리
- 디버깅 실습
- GitHub 저장소 초기화

## 📅 6월 10일 회고

### ✅ 1. 학습한 개념 요약
- 배열과 리스트의 차이
  - 배열: 고정 크기, 접근 빠름, 삽입/삭제 어려움
  - 리스트: 동적 크기, 삽입/삭제 쉬움, 접근 느림
- Java에서 배열과 ArrayList 사용법 복습

---

### 🔍 2. 문제 풀이
- [백준 11720번 - 숫자의 합](https://www.acmicpc.net/problem/11720)
- [백준 1546번 - 평균 구하기](https://www.acmicpc.net/problem/1546)

## 📅 6월 11일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 구간 합 알고리즘
- 합 배열 `S`를 만들어 누적합을 저장한 후,  
  원하는 구간의 합은 `S[j] - S[i-1]`으로 계산
- 시간복잡도를 `O(1)`로 줄이기 위해 사전 계산 방식 사용
- `S.length = A.length + 1`인 이유:  
  인덱스 `0`부터 시작해 `S[0] = 0`을 두고 `S[1] = A[0]`부터 누적해나가기 위함

#### 📌 투 포인터 알고리즘
- 두 개의 인덱스를 앞뒤로 움직이며 구간 조건을 만족하는지 탐색
- 주로 **정렬된 배열**, **부분 합**, **쌍 찾기** 등에 사용
- 시간복잡도를 `O(N)` 수준으로 줄이는 데 유리

---

### 🔍 2. 문제 풀이
- [백준 11659번 - 구간 합 구하기 1](https://www.acmicpc.net/problem/11659)
- [백준 2018번 - 연속된 자연수의 합 구하기](https://www.acmicpc.net/problem/2018)

## 📅 6월 12일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 슬라이딩 윈도우 알고리즘
- 고정된 범위의 창(window)을 좌→우로 이동하며 조건을 검사
- 이전 상태를 활용해 연산량을 줄이므로 `O(N)` 시간복잡도 가능

#### 📌 투 포인터 알고리즘 복습
- 정렬된 배열에서 쌍, 구간합 등을 빠르게 찾기 위해 사용하는 방법
- 주로 `i`, `j` 두 개의 인덱스를 활용
- 정렬이 안 되어 있다면 `O(nlogn)`가 가능한 상황인지 확인 후, 선 정렬 후 사용

---

### 🔍 2. 문제 풀이
- [백준 1940번 - 주몽의 명령](https://www.acmicpc.net/problem/1940)
- [백준 12891번 - DNA 비밀번호](https://www.acmicpc.net/problem/12891)

## 📅 6월 13일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 스택 (Stack)
- LIFO (Last In First Out) 구조
- `push()` → 데이터 삽입, `pop()` → 데이터 제거
- 괄호 검사, 수식 계산, DFS 등에서 자주 활용

#### 📌 큐 (Queue)
- FIFO (First In First Out) 구조
- `add()` → 삽입, `poll()` → 제거
- BFS, 순차적 처리 로직에서 활용
- `Queue`는 인터페이스이므로 `new Queue()`는 불가 → `LinkedList`로 구현

#### 📌 우선순위 큐 (PriorityQueue)
- 내부적으로 힙(Heap) 구조 사용
- 기본 정렬 기준은 최소 힙 (값이 작을수록 우선)
- 커스텀 정렬 시 `Comparator`를 사용하여 기준 변경

---

### 🔍 2. 문제 풀이

- [백준 1874번 - 스택 수열](https://www.acmicpc.net/problem/1874)
- [백준 2164번 - 카드2](https://www.acmicpc.net/problem/2164)
- [백준 11286번 - 절댓값 힙](https://www.acmicpc.net/problem/11286)

## 📅 6월 16일 회고

### ✅ 1. 학습한 개념 요약

#### 📌 버블 정렬 (Bubble Sort)
- 인접한 두 데이터를 비교하여 큰 값을 뒤로 보내는 방식.
- 한 번의 반복문마다 가장 큰 값이 맨 뒤로 "거품처럼" 이동.
- 구현이 간단하지만, 성능은 좋지 않음.

#### 📌 선택 정렬 (Selection Sort)
- 현재 위치에 들어갈 값을 선택해서 자리를 바꾸는 방식.
- 전체 데이터에서 가장 작은(또는 큰) 값을 골라 교환.
- 불필요한 교환이 적으나, 비교 횟수는 많음.

#### 📌 삽입 정렬 (Insertion Sort)
- 이미 정렬된 부분에 새 데이터를 삽입하는 방식.
- 현재 값을 왼쪽으로 비교해가며 적절한 위치에 삽입.
- 최선의 경우(거의 정렬된 경우)에는 O(n)의 시간복잡도를 가지나, 일반적으로는 O(n²).

---

### 🔍 2. 문제 풀이

- [백준 2750번 - 수 정렬하기 1 (버블 정렬)](https://www.acmicpc.net/problem/2750)
- [백준 1427번 - 자릿수 내림차순 정렬 (선택 정렬)](https://www.acmicpc.net/problem/1427)

---

### 🧠 3. 시간복잡도 및 특성 비교

| 정렬 방식 | 최악 시간복잡도 | 특징 |
|-----------|----------------|------|
| 버블 정렬 | O(n²)         | 가장 단순, 자주 소개되는 방식 |
| 선택 정렬 | O(n²)         | 비교는 많지만 교환이 적음 |
| 삽입 정렬 | O(n²)         | 정렬된 상태에 가까울수록 효율적 (최선 O(n)) |

---
